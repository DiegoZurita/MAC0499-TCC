%!TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101/183146

%% ------------------------------------------------------------------------- %%
\chapter{Modelos}
\label{cap:models}

Este capitulo tem como objetivo mostrar como os modelos foram escolhidos e apresentar
métricas nos dados simulados e reais.

Os resultados aqui apresentados foram obtidos no ambiente do Google Colab, uma vez que 
que este foi o ambiente escolhido para compartilhar os resultados dos nossos experimentos. 

Por fim, durante a seleção dos modelos apenas os dados simulados foram usados, uma vez
que ainda não estavamos de posse dos logs reais, portanto apenas na última seção deste capítulo
mostramos a performance do modelo escolhido nos dados reais.


\subsection{Estrutura dos dados}

No final do capitulo anterior mostrou-se como os arquivos brutos de logs foram transformados
para um formato tabular, as colunas nele contidas podem ser vistos na tabela \ref{tab:exemplo_log}. 
Aqui forneceremos um dicionário do que significa cada coluna:


\begin{itemize}
    \item ipaddress: o IP do usuário que realizou a requisição.
    \item dateandtime: a data e hora em que a requisião foi realizada.
    \item url: a url requisitada.
    \item statuscode: o codigo HTTP de retorno.
    \item bytessent: quando bytes foram retornados na requisição.
    \item refferer: contém o valor do cabeçalho Refere.
    \item useragent: o agente responsável pela requisição.
    \item malicious: variável indicadora que é 1 se a requisição é maliciosa, 0 caso contrário.
\end{itemize}


\begin{sidewaystable}
\centering

\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
    ipaddress & dateandtime & url & statuscode & bytessent & refferer & useragent & malicious \\ \hline
    192.168.0.219 & 13/May/2021:23:38:05 -0400 & /index.php & 200 & 2937 & """-""" & "Mozilla/5.0 ..." & 0 \\ \hline
    192.168.0.219 & 13/May/2021:23:38:05 -0400 & /index.php & 200 & 2937 & """-""" & "Mozilla/5.0 ..." & 0 \\ \hline
    192.168.0.219 & 13/May/2021:23:38:05 -0400 & /vulnerabilities/sqli\_blind/ & 200 & 1711 & """-""" & "Mozilla/5.0 ..." & 0 \\ \hline
    192.168.0.219 & 13/May/2021:23:38:05 -0400 & /vulnerabilities/sqli/?extraParam=... & 200 & 1675 & """-""" & "Mozilla/5.0 ..." & 0 \\ \hline
    192.168.0.219 & 13/May/2021:23:38:05 -0400 & /vulnerabilities/xss\_d/?extraParam=.... & 200 & 1839 & """-""" & "Mozilla/5.0 ..." & 1 \\ \hline
    192.168.0.219 & 13/May/2021:23:38:05 -0400 & /vulnerabilities/sqli\_blind/?extraParam.... & 200 & 1711 & """-""" & "Mozilla/5.0 ..." & 0 \\ \hline
    192.168.0.219 & 13/May/2021:23:38:05 -0400 & /about.php & 200 & 2306 & """-""" & "Mozilla/5.0 ..." & 0 \\ \hline
    192.168.0.219 & 13/May/2021:23:38:05 -0400 & /vulnerabilities/xss\_r/ & 200 & 1686 & """-""" & "Mozilla/5.0 ..." & 1 \\ \hline
\end{tabular}

\caption{Resultado final dos logs.\label{tab:exemplo_log}}

\end{sidewaystable}

De posse dessas colunas que estão nos logs, mais 3 colunas foram criadas:

\begin{itemize}
    \item url\_sem\_query: armazena a url requisitada sem o paramêtros de consulta.
    \item qtd\_query\_params: quantidade de paramêtros encontrados na query.
    \item navegador: armazena apenas o nome do navegador presente na coluna useragent.
\end{itemize}


\subsection{Preparação dos dados}

Durante o treino/validação de todos os modelos deste capitulo, o conjunto de dados original foi divido 
em treino e teste, como explicado abaixo:

\begin{itemize}
    \item treino: dados que serão usados para treinar o modelo.
    \item teste: dados não presentes no treino, com o objetivo de verificar se o modelo esta generalizando bem.
\end{itemize}

Outro ponto de atenção necessário é manter o desbalancemento da variável resposta nos 
conjuntos acima, dado que há mais requisições maliciosas do que não maliciosas. 

Por fim, dados categóricos foram transformados em números usando a técnica de OneHotEncode. Este e o item
anterior foram feitos com o auxilio dos utilitários de pré-processamento de dados do scikit-learn e do Apache Spark.

\subsection{Modelo base}

O modelo de florestar aleatória foi escolhido como modelo base. Essa escolha se deve ao fato dos autores 
terem uma familiaridade com ele de projetos anteriores. 

Para avaliar o modelo, as colunas abaixo foram escolhidas de maneira árbitrário, ja que neste ponto 
queriamos saber se modelos de árvores resolveriam nosso problema.

\begin{itemize}
    \item statuscode
    \item navegador
    \item qtd\_query\_params
    \item bytessent
\end{itemize}


Com este modelo e as colunas mencionadas conseguimos uma acurácia de 1 nos dados de teste. Surprendente, pois 
não esperavamos esse resultado na primeira tentativa, dado que se trata de um modelo base, logo suspeitamos 
que o modelo estava sobre ajustado nos dados. 

Para ter uma intuição melhor de como o modelo estava realizando a classificação, optamos por experimentar 
o modelo de árvore de decisão, dado que depurar-lo é possível.

\subsection{Depurando o modelo - árvore de decisão}

As mesmas colunas da seção anterior foram usadas para treinar uma árvore de decisão, e novamente
o modelo teve uma acurácia de 1 nos dados de treino e teste. 

Para entender como a classificação está sendo realizada, exibimos árvore final na imagem \ref{fig:primeira_arvore}. Nesse sentido, 
como os dados parassaram por um pré-processamento de OneHotEncoder vale mencionar o que significam cada índice em X:

\begin{itemize}
    \item X[0] e X[1]: é a coluna statuscode.
    \item X[3] até X[9]: indicam o navegador que foi utilizado.
    \item X[10]: é a coluna qtd\_query\_params
    \item X[11]: é a coluna bytessent
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=.9\textwidth]{figuras/primeira-arvore.png}
    \caption{Primeira árvore de decisão. \label{fig:primeira_arvore}}    
\end{figure}

Vemos que a árvore esta usando majoritariamente os dados da coluna navegador 
para realizar a classifição, o que não faz sentido, uma vez que esse dado foi simulado e o 
navegador não tem nenhuma relação com os ataques. Então removemos essa coluna da entrada 
e o resultado está na imagem \ref{fig:segunda_arvore}.


\begin{figure}
    \centering
    \includegraphics[width=.9\textwidth]{figuras/segunda_arvore.png}
    \caption{Segunda árvore de decisão. \label{fig:segunda_arvore}}    
\end{figure}

Esta versão já nos pareceu mais sólida pois ela utiliza a quantidade de paramêtros na query 
e a quantidade bytes enviados para o cliente, o que está relacionado com os ataques. Além disso,
também atingiu uma acurácia de 1.

\subsection{Escolha do modelo e considerações}

Dado o que foi apresentado nas seções anteiories, somado aos resultados encontrados no capítulo 2, escolhemos o modelo de árvore de decisão com as colunas
abaixo para realizar os experimentos e valida-lo em dados reais. 

\begin{itemize}
    \item statuscode
    \item qtd\_query\_params
    \item bytessent
\end{itemize}

Outros modelos mais complexos, como redes neurais ou xgboost, não foram considerados pois o 
objetivo deste trabalho é usar-lo em computadores onde os recursos, como memória e disco, são
limitados portanto favorecendo modelos mais simples como o escolhido.

Também vale notar que características dos logs específicas a ataques XSS e SQL Injection, como 
verificar a existência de uma consulta SQL na url, não foram criadas pois as colunas padrões 
do log foram suficientes para conseguir uma acurácia considerada boa.

\subsection{Testes em dados reais}

De posse dos dados reais mencionados na seção 4.2.2, executamos o modelo escolhido neles e atingimos 
uma acurácia de aproximadamente 0.93 no conjunto de teste. Portanto, definitivamente definitivamente
seguimos com ele nos experimentos.
